humidity = runif(n)*100
y = y_hat - 5*temperature + humidity + runif(n)*ori_sigma + rnorm(n,sd = ori_sigma)
cutout = as.logical(rbinom(n,1,p_constrained))
y[cutout] = y[cutout] * 0.1
y[y<0] = y[y<0] * 0.01
return(cbind(x,y))
}
temp = data_generator()
plot(temp)
temp = data_generator(1000,gen_type = 'cut')
plot(temp)
data_generator = function(n = 1000, seed = NULL, gen_type = 'normal'){
if(!is.null(seed)){
set.seed(seed)
}
p_constrained = 0
ori_sigma = 20
if(gen_type == 'cut' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
p_constrained = runif(1)/2.5
}
if(gen_type == 'chaos' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
ori_sigma = 200
}
x = runif(n) * 20
y_hat = 1000/(1+exp(-4*(x/8*x/8-1)))
temperature = runif(n)*40 - 10
humidity = runif(n)*100
y = y_hat - 5*temperature + humidity + runif(n)*ori_sigma + rnorm(n,sd = ori_sigma)
cutout = as.logical(rbinom(n,1,p_constrained))
y[cutout] = y[cutout] * runif(sum(cutout))
y[y<0] = y[y<0] * 0.01
return(cbind(x,y))
}
temp = data_generator(1000,gen_type = 'cut')
plot(temp)
temp = data_generator(1000,gen_type = 'cut')
plot(temp)
temp = data_generator(1000,gen_type = 'chaos')
plot(temp)
temp = data_generator(1000,gen_type = 'chaos&cut')
plot(temp)
temp = data_generator(1000,55,gen_type = 'chaos&cut')
plot(temp)
temp = data_generator(1000,55,gen_type = 'chaos&cut')
plot(temp)
View(temp)
#' Title
#'
#' @param n
#' @param seed
#' @param gen_type
#'
#' @return
#' @export
#'
#' @examples
data_generator = function(n = 1000, seed = NULL, gen_type = 'normal'){
if(!is.null(seed)){
set.seed(seed)
}
p_constrained = 0
ori_sigma = 20
if(gen_type == 'cut' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
p_constrained = runif(1)/2.5
}
if(gen_type == 'chaos' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
ori_sigma = 200
}
x = runif(n) * 20
y_hat = 1000/(1+exp(-4*(x/8*x/8-1)))
temperature = runif(n)*40 - 10
humidity = runif(n)*100
y = y_hat - 5*temperature + humidity + runif(n)*ori_sigma + rnorm(n,sd = ori_sigma)
cutout = as.logical(rbinom(n,1,p_constrained))
y[cutout] = y[cutout] * runif(sum(cutout))
y[y<0] = y[y<0] * 0.01
return(cbind(x,y,temperature,humidity))
}
temp = data_generator(1000,55,gen_type = 'chaos&cut')
plot(temp)
View(temp)
#' @param n sample size simulated
#' @param seed random seed
#' @param gen_type can be 'cut', 'chaos', 'cut&chaos' or 'chaos&cut' except for 'normal'. 'cut' means some effects will be shrinked; 'chaos' means random errors will be much more than normal
#'
#' @return a simulated dataset with [x,y,temperature,humidity]
#' @export
#'
#' @examples
#' temp = data_generator(1000,55,gen_type = 'chaos&cut')
#' plot(temp)
data_generator = function(n = 1000, seed = NULL, gen_type = 'normal'){
if(!is.null(seed)){
set.seed(seed)
}
p_constrained = 0
ori_sigma = 20
if(gen_type == 'cut' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
p_constrained = runif(1)/2.5
}
if(gen_type == 'chaos' | gen_type == 'cut&chaos' | gen_type == 'chaos&cut'){
ori_sigma = 200
}
x = runif(n) * 20
y_hat = 1000/(1+exp(-4*(x/8*x/8-1)))
temperature = runif(n)*40 - 10
humidity = runif(n)*100
y = y_hat - 5*temperature + humidity + runif(n)*ori_sigma + rnorm(n,sd = ori_sigma)
cutout = as.logical(rbinom(n,1,p_constrained))
y[cutout] = y[cutout] * runif(sum(cutout))
y[y<0] = y[y<0] * 0.01
return(cbind(x,y,temperature,humidity))
}
temp1 = data_sieve(temp[,1],temp[,2],c(0.7,0.85,5000))
data_sieve = function(x, y, coeffs = c(0.7, 0.9, 750),
gap_percentage = 0.01, if_plot = TRUE){
#参数：筛前速度、筛前功率、装机容量、筛选参数、最近邻半边比例、是否做图
#其中参数有三个值：附近下分位点、功率误差限、装机容量允差限
order_x = order(x,decreasing = FALSE)
n_data = length(x)
x_gap = ceiling(n_data*gap_percentage)
#半边区域的最小值段、最大值段（在循环后）予以保留
out_x = x[order_x[1:x_gap]]
out_y = y[order_x[1:x_gap]]
out_indicator = order_x[1:x_gap]
for(i in (x_gap+1):(n_data-x_gap-1)){
#自小到大判断是否归入输出值
cmp_y = y[order_x[(i-x_gap):(i+x_gap)]]
cmp_threshold = as.numeric(quantile(cmp_y, probs = coeffs[1]))
#扣除10%的误差限和5%的装机容量，避免太过严格
cmp_threshold = cmp_threshold*coeffs[2] - coeffs[3]
if(y[order_speed[i]] > cmp_threshold){
out_x = c(out_x, x[order_x[i]])
out_y = c(out_power, y[order_x[i]])
out_indicator = c(out_indicator, order_x[i])
}
}
out_x = c(out_x, x[order_x[(n_data-x_gap+1):n_data]])
out_y = c(out_y, y[order_x[(n_data-x_gap+1):n_data]])
out_indicator = c(out_indicator, order_x[(n_data-x_gap+1):n_data])
if(if_plot){
plot(x, y, pch='*')
points(out_x, out_y, pch='*', col='red')
}
return(list(x = out_x, y = out_y, indicator = out_indicator))
}
temp1 = data_sieve(temp[,1],temp[,2],c(0.7,0.85,5000))
data_sieve = function(x, y, coeffs = c(0.7, 0.9, 750),
gap_percentage = 0.01, if_plot = TRUE){
#参数：筛前速度、筛前功率、装机容量、筛选参数、最近邻半边比例、是否做图
#其中参数有三个值：附近下分位点、功率误差限、装机容量允差限
order_x = order(x,decreasing = FALSE)
n_data = length(x)
x_gap = ceiling(n_data*gap_percentage)
#半边区域的最小值段、最大值段（在循环后）予以保留
out_x = x[order_x[1:x_gap]]
out_y = y[order_x[1:x_gap]]
out_indicator = order_x[1:x_gap]
for(i in (x_gap+1):(n_data-x_gap-1)){
#自小到大判断是否归入输出值
cmp_y = y[order_x[(i-x_gap):(i+x_gap)]]
cmp_threshold = as.numeric(quantile(cmp_y, probs = coeffs[1]))
#扣除10%的误差限和5%的装机容量，避免太过严格
cmp_threshold = cmp_threshold*coeffs[2] - coeffs[3]
if(y[order_x[i]] > cmp_threshold){
out_x = c(out_x, x[order_x[i]])
out_y = c(out_y, y[order_x[i]])
out_indicator = c(out_indicator, order_x[i])
}
}
out_x = c(out_x, x[order_x[(n_data-x_gap+1):n_data]])
out_y = c(out_y, y[order_x[(n_data-x_gap+1):n_data]])
out_indicator = c(out_indicator, order_x[(n_data-x_gap+1):n_data])
if(if_plot){
plot(x, y, pch='*')
points(out_x, out_y, pch='*', col='red')
}
return(list(x = out_x, y = out_y, indicator = out_indicator))
}
temp1 = data_sieve(temp[,1],temp[,2],c(0.7,0.85,5000))
temp1 = data_sieve(temp[,1],temp[,2],c(0.7,0.85,500))
#' @param x
#' @param y
#' @param cuts
#' @param loss
#' @param params
#'
#' @return
#' @export
#'
#' @examples
sum_loss = function(deltas, x, y, cuts, loss, params = NULL){
#分别是对应断点的y值加上初始和最终的斜率
#初始值可设置为线性+斜率0
#x y是输入数据
#cuts是固定断点
#params是子误差函数输入参数
if(is.null(params)){
loss_func = function(x, temp = NULL){
# add a blank parameter from original one-input loss function
return(loss(x))
}
}
else{
loss_func = loss
}
n_delta = length(deltas) - 2
term_1 = I(x < cuts[1]) *
loss_func(y - deltas[1] - deltas[n_delta+1]*(x-cuts[1]),params)
term_1 = sum(term_1)
for(i in 2:n_delta){
indicator = I(x >= cuts[i-1] & x < cuts[i])
tp_tangent = (deltas[i]-deltas[i-1])/(cuts[i]-cuts[i-1])
y_hat = deltas[i-1] + tp_tangent*(x-cuts[i-1])
term_mid = indicator * loss_func(y_hat-y,params)
term_1 = term_1 + sum(term_mid)
}
term_last = I(x >= cuts[n_delta]) *
loss_func(y - deltas[n_delta] - deltas[n_delta+2]*(x-cuts[n_delta]),params)
return(term_1 + sum(term_last))
}
sum_loss(c(10000,20000,30000,0),temp[,1],temp[,2],c(5,10,15),c(3,100))
sum_loss(c(10000,20000,30000,0),temp[,1],temp[,2],c(5,10,15),sim_sigmoid_soft, c(3,100))
sum_loss(c(100,200,300,0,0),temp[,1],temp[,2],c(5,10,15),sim_sigmoid_soft, c(3,100))
sum_loss(c(100,200,350,0,0),temp[,1],temp[,2],c(5,10,15),sim_sigmoid_soft, c(3,100))
sum_loss(c(10,200,350,0,0),temp[,1],temp[,2],c(5,10,15),sim_sigmoid_soft, c(3,100))
nlminb(c(10,200,350,0,0),sum_loss,
x=temp[,1],y=temp[,2],
cuts=c(5,10,15),params=c(5,100))
nlminb(c(10,200,350,0,0),sum_loss,
x=temp[,1],y=temp[,2],
cuts=c(5,10,15),params=c(5,100),loss=sim_sigmoid_soft)
plot(temp[,1],temp[,2])
#' Loss function of L(x) = x^2
#'
#' @param x original error
#'
#' @return loss
#' @export
#'
#' @examples
#' plot(1:100,L2(1:100))
L2 = function(x){
return(x^2)
}
nlminb(c(10,200,350,0,0),sum_loss, x=temp[,1],y=temp[,2],
cuts=c(5,10,15),loss=L2)
message('1')
return()
warning('1')
SLM_construct = function(x, y, fixed_psi,
loss_function = L2, params = NULL, init_val = NULL){
n_fixed_psi = length(fixed_psi)
if(is.null(init_val)){
init_val = rep(n_fixed_psi,mean(y))
init_val = c(init_val,0,0)
}
output = nlminb(init_val,sum_loss, x=x,y=y,
cuts=fixed_psi,loss=loss_function, params = params)
if(!output$convergence){
warning('warning: nlminb not converge')
}
return(list(x=fixed_psi, y=output$par[1:n_fixed_psi],
init_tangent = output$par[n_fixed_psi+1],
final_tangent = output$par[n_fixed_psi+2],
loss = output$objective))
}
SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
warnings()
nlminb(c(100,100,100,100,0,0),sum_loss, x=temp[,1],y=temp[,2],
cuts=c(2,6,8,10),loss=L2, params = NULL)
SLM_construct = function(x, y, fixed_psi,
loss_function = L2, params = NULL, init_val = NULL){
n_fixed_psi = length(fixed_psi)
if(is.null(init_val)){
init_val = rep(n_fixed_psi,mean(y))
init_val = c(init_val,0,0)
}
print(init_val)
print(loss_function)
print(params)
output = nlminb(init_val,sum_loss, x=x,y=y,
cuts=fixed_psi,loss=loss_function, params = params)
if(!output$convergence){
warning('warning: nlminb not converge')
}
return(list(x=fixed_psi, y=output$par[1:n_fixed_psi],
init_tangent = output$par[n_fixed_psi+1],
final_tangent = output$par[n_fixed_psi+2],
loss = output$objective))
}
SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
SLM_construct = function(x, y, fixed_psi,
loss_function = L2, params = NULL, init_val = NULL){
n_fixed_psi = length(fixed_psi)
if(is.null(init_val)){
init_val = rep(n_fixed_psi,mean(y))
init_val = c(init_val,0,0)
}
print(n_fixed_psi)
output = nlminb(init_val,sum_loss, x=x,y=y,
cuts=fixed_psi,loss=loss_function, params = params)
if(!output$convergence){
warning('warning: nlminb not converge')
}
return(list(x=fixed_psi, y=output$par[1:n_fixed_psi],
init_tangent = output$par[n_fixed_psi+1],
final_tangent = output$par[n_fixed_psi+2],
loss = output$objective))
}
SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
rep(4,1)
rep(1,4)
SLM_construct = function(x, y, fixed_psi,
loss_function = L2, params = NULL, init_val = NULL){
n_fixed_psi = length(fixed_psi)
if(is.null(init_val)){
init_val = rep(mean(y),n_fixed_psi)
init_val = c(init_val,0,0)
}
print(n_fixed_psi)
output = nlminb(init_val,sum_loss, x=x,y=y,
cuts=fixed_psi,loss=loss_function, params = params)
if(!output$convergence){
warning('warning: nlminb not converge')
}
return(list(x=fixed_psi, y=output$par[1:n_fixed_psi],
init_tangent = output$par[n_fixed_psi+1],
final_tangent = output$par[n_fixed_psi+2],
loss = output$objective))
}
SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
SLM_construct = function(x, y, fixed_psi,
loss_function = L2, params = NULL, init_val = NULL){
n_fixed_psi = length(fixed_psi)
if(is.null(init_val)){
init_val = rep(mean(y),n_fixed_psi)
init_val = c(init_val,0,0)
}
output = nlminb(init_val,sum_loss, x=x,y=y,
cuts=fixed_psi,loss=loss_function, params = params)
if(output$convergence){
warning('warning: nlminb not converge')
}
return(list(x=fixed_psi, y=output$par[1:n_fixed_psi],
init_tangent = output$par[n_fixed_psi+1],
final_tangent = output$par[n_fixed_psi+2],
loss = output$objective))
}
SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
model_1 = SLM_construct(temp[,1],temp[,2],fixed_psi = c(2,6,8,10))
predict_model = function(one_model, newdata){
n_psi = length(one_model$x)
x_min = min(newdata) - 1
x_max = max(newdata) + 1
y_min = one_model$y[1] + one_model$init_tangent*(x_min-one_model$x[1])
y_max = one_model$y[n_psi] + one_model$final_tangent*(x_max-one_model$x[n_psi])
x = c(x_min,one_model$x,x_max)
y = c(y_min,one_model$y,y_max)
return(approx(x,y,xout = newdata)$y)
}
predict_model(model_1, c(0,1,10,100,0.5,-1333))
predict_model = function(one_model, newdata){
n_psi = length(one_model$x)
x_min = min(newdata) - 1
x_max = max(newdata) + 1
y_min = one_model$y[1] + one_model$init_tangent*(x_min-one_model$x[1])
y_max = one_model$y[n_psi] + one_model$final_tangent*(x_max-one_model$x[n_psi])
x = c(x_min,one_model$x,x_max)
y = c(y_min,one_model$y,y_max)
return(approx(x,y,xout = newdata)$y)
}
draw_lines_model = function(one_model, model_col = 'blue',
x_beg = -100, x_end = 100){
#在已有plot的基础上画线
#默认过原点，最后一点之后斜率为0
x = c(x_beg, one_model$x, x_end)
y = predict_model(one_model, c(x_beg,x_end))
y = c(y[1], one_model$y, y[2])
lines(x,y,col = model_col)
}
draw_lines_model(model_1,'red')
draw_lines_model(model_1,'red')
tryCatch({lines(1,1)},error = function(e){print(e)})
x = tryCatch({lines(1,1)},error = function(e){(e)})
x
typeof(x)
x[[1]]
x = tryCatch({1},error = function(e){(e)})
x
x = tryCatch({plot(1,1)},error = function(e){(e)})
x
errorCondition()
typeof(x)
#'
#' @param one_model the model generated by function 'SLM_construct'
#' @param model_col color of line for the drawing
#' @param x_beg lowest x value for drawing, default -100
#' @param x_end largest x value for drawing, default 100
#'
#' @return NULL
#' @export
#'
#' @examples
draw_lines_model = function(one_model, model_col = 'blue',
x_beg = -100, x_end = 100){
#在已有plot的基础上画线
#默认过原点，最后一点之后斜率为0
x = c(x_beg, one_model$x, x_end)
y = predict_model(one_model, c(x_beg,x_end))
y = c(y[1], one_model$y, y[2])
err = tryCatch({lines(x,y,col = model_col)},error = function(e){(e)})
if(typeof(err) == 'list'){
if(err[[1]] == 'plot.new has not been called yet'){
message('Draw new line failed. Note that this function adds a new line under an EXISTING plot.')
}
}
}
draw_lines_model(model_1,'red')
dev.off
dev.off()
plot(1,1)
plot(1:2,2:3)
dev.off()
devtools::document()
disperse_level(temp[,1],temp[,2])
#' @param x_data data of dimension 1
#' @param y_data data of dimension 2
#' @param nx how many blocks in x-axis
#' @param ny how many blocks in y-axis
#'
#' @return a real number corresponding how much it disperses
#' @export
#'
#' @examples
#'
disperse_level = function(x_data, y_data, nx = 5, ny = 5){
max_x = max(x_data) + 0.1
min_x = min(x_data) - 0.1
max_y = max(y_data) + 0.1
min_y = min(y_data) - 0.1
gap_x = (max_x - min_x)/nx
gap_y = (max_y - min_y)/ny
loc_x = floor((x_data - min_x)/gap_x)
loc_y = floor((y_data - min_y)/gap_y) + 1
loc_xy = loc_x*ny + loc_y
output = rep(0,nx*ny)
for(i in 1:(length(x_data))){
output[loc_xy[i]] = output[loc_xy[i]] + 1
}
print(output)
output = output/length(x_data)
output[output == 0] = NA
output = na.omit(output)
return(sum(-output*log2(output)))
}
disperse_level(temp[,1],temp[,2])
#' @param x_data data of dimension 1
#' @param y_data data of dimension 2
#' @param nx how many blocks in x-axis
#' @param ny how many blocks in y-axis
#'
#' @return a real number corresponding how much it disperses
#' @export
#'
#' @examples
#'
disperse_level = function(x_data, y_data, nx = 5, ny = 5){
max_x = max(x_data) + 0.1
min_x = min(x_data) - 0.1
max_y = max(y_data) + 0.1
min_y = min(y_data) - 0.1
gap_x = (max_x - min_x)/nx
gap_y = (max_y - min_y)/ny
loc_x = floor((x_data - min_x)/gap_x)
loc_y = floor((y_data - min_y)/gap_y) + 1
loc_xy = loc_x*ny + loc_y
output = rep(0,nx*ny)
for(i in 1:(length(x_data))){
output[loc_xy[i]] = output[loc_xy[i]] + 1
}
output = output/length(x_data)
output[output == 0] = NA
output = na.omit(output)
return(sum(-output*log2(output)))
}
disperse_level(temp[,1],temp[,2])
temp = data_generator(1000,55,gen_type = 'normal')
disperse_level(temp[,1],temp[,2])
devtools::document()
load_all()
devtools::load_all()
rm(list = c("data_generator", "data_sieve", "disperse_level", "draw_lines_model",
"L1_shrink", "L2", "predict_model", "sim_sigmoid_hard", "sim_sigmoid_soft", "SLM_construct",
"sum_loss"))
devtools::document()
devtools::document()
hello()
library(roxygen2)
roxygenize（
roxygenize()
getwd()
devtools::check("slmwclf")
devtools::check("D:/DATA/个人项目/slmwclf/slmwclf")
devtools::check("D:/DATA/个人项目/slmwclf/slmwclf")
devtools::check("D:/DATA/个人项目/slmwclf/slmwclf")
update(Rtools)
update('Rtools')
update.packages(Rtools)
update.packages('Rtools')
devtools::build('D:/DATA/个人项目/slmwclf/')
devtools::build('D:/DATA/个人项目/slmwclf/slmwclf/')
